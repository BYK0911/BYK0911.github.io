(function(n){function e(e){for(var r,o,i=e[0],d=e[1],s=e[2],u=0,l=[];u<i.length;u++)o=i[u],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&l.push(a[o][0]),a[o]=0;for(r in d)Object.prototype.hasOwnProperty.call(d,r)&&(n[r]=d[r]);m&&m(e);while(l.length)l.shift()();return c.push.apply(c,s||[]),t()}function t(){for(var n,e=0;e<c.length;e++){for(var t=c[e],r=!0,o=1;o<t.length;o++){var i=t[o];0!==a[i]&&(r=!1)}r&&(c.splice(e--,1),n=d(d.s=t[0]))}return n}var r={},o={app:0},a={app:0},c=[];function i(n){return d.p+"js/"+({about:"about","doc~doc-editor~doc-reader":"doc~doc-editor~doc-reader",doc:"doc","doc-editor":"doc-editor","doc-reader":"doc-reader",firework:"firework",home:"home"}[n]||n)+"."+{about:"6a750536","doc~doc-editor~doc-reader":"6528535e",doc:"53cf85f2","doc-editor":"4cd7d4b1","doc-reader":"b9bdc7ce",firework:"8c8fe237",home:"34be6cfd"}[n]+".js"}function d(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,d),t.l=!0,t.exports}d.e=function(n){var e=[],t={about:1,doc:1,"doc-editor":1,"doc-reader":1,home:1};o[n]?e.push(o[n]):0!==o[n]&&t[n]&&e.push(o[n]=new Promise((function(e,t){for(var r="css/"+({about:"about","doc~doc-editor~doc-reader":"doc~doc-editor~doc-reader",doc:"doc","doc-editor":"doc-editor","doc-reader":"doc-reader",firework:"firework",home:"home"}[n]||n)+"."+{about:"465b2676","doc~doc-editor~doc-reader":"31d6cfe0",doc:"211f0b3b","doc-editor":"ca700857","doc-reader":"3b934e90",firework:"31d6cfe0",home:"8bcd7a49"}[n]+".css",a=d.p+r,c=document.getElementsByTagName("link"),i=0;i<c.length;i++){var s=c[i],u=s.getAttribute("data-href")||s.getAttribute("href");if("stylesheet"===s.rel&&(u===r||u===a))return e()}var l=document.getElementsByTagName("style");for(i=0;i<l.length;i++){s=l[i],u=s.getAttribute("data-href");if(u===r||u===a)return e()}var m=document.createElement("link");m.rel="stylesheet",m.type="text/css",m.onload=e,m.onerror=function(e){var r=e&&e.target&&e.target.src||a,c=new Error("Loading CSS chunk "+n+" failed.\n("+r+")");c.code="CSS_CHUNK_LOAD_FAILED",c.request=r,delete o[n],m.parentNode.removeChild(m),t(c)},m.href=a;var p=document.getElementsByTagName("head")[0];p.appendChild(m)})).then((function(){o[n]=0})));var r=a[n];if(0!==r)if(r)e.push(r[2]);else{var c=new Promise((function(e,t){r=a[n]=[e,t]}));e.push(r[2]=c);var s,u=document.createElement("script");u.charset="utf-8",u.timeout=120,d.nc&&u.setAttribute("nonce",d.nc),u.src=i(n);var l=new Error;s=function(e){u.onerror=u.onload=null,clearTimeout(m);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var m=setTimeout((function(){s({type:"timeout",target:u})}),12e4);u.onerror=u.onload=s,document.head.appendChild(u)}return Promise.all(e)},d.m=n,d.c=r,d.d=function(n,e,t){d.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},d.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},d.t=function(n,e){if(1&e&&(n=d(n)),8&e)return n;if(4&e&&"object"===typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(d.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)d.d(t,r,function(e){return n[e]}.bind(null,r));return t},d.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return d.d(e,"a",e),e},d.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},d.p="",d.oe=function(n){throw console.error(n),n};var s=window["webpackJsonp"]=window["webpackJsonp"]||[],u=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var m=u;c.push([0,"chunk-vendors"]),t()})({0:function(n,e,t){n.exports=t("cd49")},"27dc":function(n,e,t){},"405a":function(n){n.exports=JSON.parse('{"value":{"id":"1645433358746","title":"Canvas 绘制路径","content":"# Canvas 路径\\n上一节中我们学习了绘制矩形、文字、图片的方法，接下我们将学习另一类更强大的工具—— 路径（Path）。\\n\\n不管是画直线、曲线、圆弧，甚至是更复杂的几何图形，我们都称之为路径的绘制。\\n\\n接下来我们将学习使用路径 api 来画出我们想要的形状，并对其进行描边或填充。\\n\\n## 开始和结束路径\\nbeginPath 和 closePath，这是两个成对出现的api，在开始绘制路径之前调用beginPath，路径绘制完成后调用 closePath 闭合路径。\\n```\\n// 开始路径绘制\\nctx.beginPath();\\n// 绘制路径\\n... \\n// 闭合路径\\nctx.closePath();\\n```\\n\\n## 绘制直线\\n通过以下步骤，我们可以画一条从（10，10）到（100，10）的水平直线。\\n```\\n// 开始路径\\nctx.beginPath();\\n// 将画笔移动到指定坐标\\nctx.moveTo(10, 10)；\\n// 连接到指定坐标\\nctx.lineTo(100, 10);\\n// 结束路径\\nctx.closePath();\\n// 描边路径\\nctx.stroke();\\n```\\n结合上一节所学的线型的设置，我们则可以绘制出任意样式的直线。\\n\\n如果多次调用lineTO连接更多的点，则可以绘制任意形状的折线或几何图形。\\n```\\n// 绘制一个蓝色三角形\\nctx.fillStyle = \'blue\';\\nctx.beginPath();\\nctx.moveTo(50, 0)；\\nctx.lineTo(0, 100);\\nctx.lineTo(0, 100);\\nctx.closePath();\\nctx.stroke();\\n// 填充路径\\nctx.fill();\\n```\\n\\n## 绘制圆弧\\n绘制圆弧有以下两种场景：\\n* 已知圆心和半径画圆或圆弧\\n* 已知两条相交的线画圆角\\n### 绘制圆或圆弧\\n```\\n/**\\n * arc\\n * @param{Number} x 横坐标\\n * @param{Number} y 纵坐标\\n * @param{Number} r 半径\\n * @param{Number} startAngle 起始角度\\n * @param{Number} endAngle 结束角度\\n * @param{Number} antiClockWise 是否是逆时针\\n\\n// 在（50，50）位置画一个半径为10的圆，颜色为蓝色\\nctx.beginPath();\\nctx.arc(50, 50, 10, 0, Math.PI * 2);\\nctx.closePath();\\nctx.fillStyle = \'blue\';\\nctx.fill();\\n\\n// 改变起始角度和结束角度来绘制圆弧\\nctx.beginPath();\\nctx.arc(50, 50, 10, -Math.PI, 0);\\nctx.strokeStyle = \'red\';\\nctx.stroke();\\nctx.closePath();\\n```\\n\\n### 绘制圆角\\n```\\n/**\\n * arcTo\\n * @param{Number} x1 横坐标\\n * @param{Number} y1 纵坐标\\n * @param{Number} x2 横坐标\\n * @param{Number} y2 纵坐标\\n * @param{Number} r 半径\\n\\n// 在（10，10）,（100，10）,（100，100）三个点构成的角上，用半径为10的圆弧来过渡。\\nctx.beginPath();\\nctx.moveTo(10, 10);\\nctx.arcTo(100, 10, 100, 100, 10);\\nctx.strokeStyle = \'black\';\\nctx.stroke();\\nctx.closePath();\\n```\\n## 绘制曲线\\n在几何的世界里，除了棱角分明的直线构成的几何体，还有由平滑的曲线构成的几何体。canvas提供了两种绘制曲线的方式：\\n* qudraticCurveTo 一次贝塞尔曲线\\n* besizerCurveTo 二次贝塞尔曲线\\n### 一次贝塞尔曲线\\n一次贝塞尔曲线是用一个控制点将两个点用平滑的曲线连接起来\\n```\\n/**\\n * qudraticCurveTo\\n * @param{Number} cx1 控制点1横坐标\\n * @param{Number} cy1 控制点1纵坐标\\n * @param{Number} x2 横坐标\\n * @param{Number} y2 纵坐标\\n\\n// 通过控制点（50，50）将（10，10）（100，10）用平滑的曲线连接起来\\nctx.beginPath();\\nctx.moveTo(10, 10);\\nctx.besizerCurveTo(50, 50, 100, 50);\\nctx.strokeStyle = \'black\';\\nctx.stroke();\\nctx.closePath();\\n```\\n\\n### 二次贝塞尔曲线\\n一次贝塞尔曲线则是用两个控制点将两个点用平滑的曲线连接起来\\n```\\n/**\\n * besizerCurveTo\\n * @param{Number} cx1 控制点1横坐标\\n * @param{Number} cy1 控制点1纵坐标\\n * @param{Number} cx2 控制点2横坐标\\n * @param{Number} cy2 控制点2纵坐标\\n * @param{Number} x2 横坐标\\n * @param{Number} y2 纵坐标\\n\\n// 通过控制点（50，50）（100，50）将（10，10）（150，10）用平滑的曲线连接起来\\nctx.beginPath();\\nctx.moveTo(10, 10);\\nctx.besizerCurveTo(50, 50, 100, 50, 150, 10);\\nctx.strokeStyle = \'black\';\\nctx.stroke();\\nctx.closePath();\\n```\\n## 路径剪切\\n当你想在某个范围内绘制图形的时候，我们需要先绘制出这个范围的路径，然后剪切路径，就可以在路径范围内绘制图形，超出的部分自动就不再显示了\\n```\\n// 在一个以（50，50）为圆心，50为半径的圆形内，在（0，0）位置画一张100*100的图\\nctx.beginPath();\\nctx.arc(50, 50, 50, 0, Math.PI);\\nctx.closePath();\\nctx.clip()\\nctx.drawImage(img, 0, 0, 100, 100);\\n```","topic":"Canvas 绘图","keywords":["canvas","js"]}}')},"490c":function(n,e,t){"use strict";t("e9c4");e["a"]={set:function(n,e){var t={value:e};localStorage.setItem(n+"",JSON.stringify(t))},get:function(n){var e=localStorage.getItem(n);return e?JSON.parse(e).value:null}}},"56af":function(n){n.exports=JSON.parse('{"value":{"id":"1646288680934","title":"Canvas 特效","content":"* [烟花](/demo/canvas/firework)\\n* [写字板](https://byk0911.github.io/vue-canvas-demo/#/handwriting)\\n* [雪花飞舞](https://byk0911.github.io/vue-canvas-demo/#/snow)","topic":"Canvas 绘图","keywords":["canvas","js","html5"]}}')},"5b24":function(n){n.exports=JSON.parse('{"value":{"id":"1646029388219","title":"CEP 简介","content":"1. [CEP 简介](https://byk0911.github.io/#/doc/1646029388219)\\n2. [CEP 插件目录结构](https://byk0911.github.io/)\\n3. [搭建开发环境](https://byk0911.github.io/)\\n4. [CEP 开发调试](https://byk0911.github.io/)\\n5. [初步了解 CSInterface](https://byk0911.github.io/)\\n6. [初步了解 ExtendScript](https://byk0911.github.io/)\\n7. [Action Manager 简介](https://byk0911.github.io/)\\n8. [Events](https://byk0911.github.io/)\\n9. [签名打包](https://byk0911.github.io/)\\n\\n### 什么是 CEP ?\\nCEP（Common Extension Platform）是 Adobe 产品的通用扩展平台。\\n\\nCEP 插件其实是运行在宿主软件窗口中的浏览器页面。\\n\\n使用 HTML、Javascript、CSS 及 node 技术开发扩展插件来扩展宿主软件的功能。\\n\\n### CEP 中的 JS 脚本\\n在 CEP 扩展程序中有两类 javascript 脚本，分别运行在不同的运行环境中：\\n\\n* 一类运行在 ExtendScript 脚本解析其中，我们称之为 host 端的 jsx 脚本。\\n* 一类运行在宿主环境内置的 Chromium 内核浏览器及 node 环境中，我们称之为 client 端 js 脚本。\\n\\n### 推荐阅读\\n* [Adobe-CEP 官方文档](https://github.com/Adobe-CEP/CEP-Resources)\\n* [零基础的 PhotoShop CEP 6 开发教程](https://www.jianshu.com/p/48b48c9f0b0a)","topic":"Adobe CEP 插件开发","keywords":["PS","CEP","Adobe","photoshop"]}}')},"5dcd":function(n){n.exports=JSON.parse('{"value":{"id":"1645435264368","title":"Git 常用操作","content":"## Git\\n\\n###  获取Git仓库\\n\\n``` bash\\n# 初始化仓库\\ngit init \\n\\n# 克隆仓库\\ngit clone <url> [project-name]\\n```\\n\\n### 远程仓库\\n```bash\\n# 查看远程仓库\\ngit remote\\n\\n# 显示仓库url\\ngit remote -v\\n\\n# 添加远程仓库\\ngit remote add <shortname> <url>\\n\\n# 从远程仓库拉取信息\\ngit fetch [remote-name]\\n\\n# 拉取并合并\\ngit pull [remote-name]\\n\\n# 推送到远程分支\\ngit push [remote-name remote-branch]\\n\\n# 查看远程仓库信息\\ngit remote show <remote-name>\\n\\n# 远程仓库重命名\\ngit remote rename <name-old> <name-new>\\n\\n# 移除远程仓库\\ngit remote rm <remote-name>\\n\\n```\\n\\n### 分支管理 \\n```bash\\n# 查看分支列表\\ngit branch\\n\\n# 查看每一个分支的最后一次提交\\ngit branch -v \\n\\n# 创建并切换到新的分支\\ngit checkout -b <branch-name> \\n\\n# 切换分支\\ngit checkout <branch-name>\\n\\n# 删除分支\\ngit branch -d <branch-name>\\n\\n# 强制删除分支\\ngit branch -D <branch-name> \\n\\n# 查看哪些分支已经合并到当前分支\\ngit branch --merged\\n\\n# 查看尚未合并到当前分支的分支\\ngit branch --no-merged \\n\\n```\\n\\n### 暂存和提交\\n```bash\\n# 查看文件状态\\ngit status\\n\\n# 跟踪新文件 或 暂存已更改文件，还能用于合并时把有冲突的文件标记为已解决的状态等\\ngit add <file>\\n\\n# 新添加的未跟踪文件前边有??标记\\n# 新添加到暂存区的文件前边有A标记\\n# 修改过的文件前边有M标记\\n# M放在右边标识文件修改过但是还没有放到暂存区\\n# M出现在左边标识文件修改过并已放入暂存区\\n\\ngit status -s | git status --short\\n\\n# 查看已暂存和未暂存的修改\\n# 查看尚未暂存的文件更新了哪些部分\\n# 此命令查看的是工作目录与暂存区的差异，也就是修改之后还没有暂存起来的变化\\ngit diff \\n\\n# 查看已经暂存起来的将要添加到下次提交的内容\\ngit diff --cached | git diff --staged\\n\\n# 提交更新\\ngit commit | git commit -m \\n\\n# 暂存并提交\\ngit commit -a | git commit -a -m\\n\\n# 移除文件，要从git中移除某个文件，就必须要从暂存区域移除\\ngit rm <file> # 连带从工作目录中删除指定文件\\n\\n# 如果删除之前修改过，并且已经放入到暂存区的话，则必须使用强制删除选项-f    \\ngit rm -f <file>\\n\\n# 把文件从暂存区移除\\ngit rm --cached <file>\\n\\n# 移动文件或修改文件名称\\ngit mv <file-old> <file-new>\\n```\\n\\n### 撤销\\n```bash\\n# 修改上次提交\\ngit commit --amend | git commit --amend -m\\n\\n# 取消暂存文件\\ngit reset HEAD <file>\\n\\n# 撤销对文件的修改\\ngit checkout -- <file>\\n```\\n\\n### 提交日志\\n```bash\\ngit log\\n\\n# 显示每次提交之间的差异\\ngit log -p \\n\\n# 显示最近 n 次的提交\\ngit log -<n>\\n\\n# 显示简略统计信息\\ngit log --stat\\n\\ngit log --pretty=<oneline|short|full|fuller>\\n\\n# %H完整哈希字串，%h简短哈希字串\\n# %T树对象完整哈希字串，%t树对象简短字串\\n# %P父对象哈希，%p父对象简短哈希字串\\n# %an作者名字，%ae作者电子邮箱 \\n# %ad作者修订日期，%ar作者修订日期（按多久以前的方式显示）\\n# %cn提交者的名字，%ce提交者邮箱\\n# %cd提交日期, %cr提交日期（按多久以前显示）, %cs提交说明 \\ngit log --pretty=format:\\"<输出规则>\\" \\n\\n# 以ASCII图形显示提交合并历史\\ngit log --graph\\n\\ngit log --since=<日期> | git log --until=<> | git log --before= | git log --after=\\ngit log --grep=<keywords>\\ngit log --author=<authorname>\\ngit log --committer=<committer>\\n```\\n\\n### 标签管理\\n```bash\\n# 列出标签\\ngit tag\\n\\n# 打标签\\ngit tag -a <tag-name> -m <msg> # 创建带附注的标签\\ngit tag <tag-name> # 创建轻量标签\\ngit tag -a <tag-name> <哈希字串> # 后期打标签\\n\\n# 查看标签信息\\ngit show <tag-name>\\n\\n# 推送标签到远程仓库\\ngit push <remote-name> <tagname>\\n\\n# 推送所有标签\\ngit push <remote-name> --tags\\n\\n# 在指定的标签上创建分支\\ngit checkout -b <branch-name> <tag-name> \\n```\\n","topic":"","keywords":["git"]}}')},"5e74":function(n){n.exports=JSON.parse("{\"value\":{\"id\":\"1645433309313\",\"title\":\"Canvas 绘图基础\",\"content\":\"# canvas 基本绘图\\n本篇文章主要涉及以下内容\\n* 画笔上下文\\n* 绘制矩形\\n* 绘制文本\\n* 绘制图片\\n\\n## 画笔上下文\\n画笔上下文对象（CanvasRenderingContext）是canvas绘图的核心对象，绘图api都挂载在上下文对象上。\\n\\n### 获取画笔上下文对象\\n首先获取 canvas dom 元素，调用 getContext api 传入固定参数'2d'获取上下文对象:\\n```\\n// html中有canvas节点：<canvas id='cvs'></canvas>\\n// 获取 canvas 元素\\nconst cvs = document.getElementById('cvs');\\n// 获取上下文对象\\nconst ctx = canvas.getContext('2d');\\n```\\n\\n### 上下文对象的常用属性设置\\n绘图过程中，画笔的颜色、字体、线型等状态，上下文对象都提供了相应的api来进行设置。\\n\\n#### 颜色设置\\n```\\n// css中所支持的颜色，均可以在画笔上下文上使用;\\n\\n// 通过 fillStyle 设置填充色;\\nctx.fillStyle = '#fff';\\nctx.fillStyle = 'rgba(255,255,255,1);\\nctx.fillStyle = 'white';\\n\\n// 通过 strokeStyle 设置描边颜色；\\nctx.strokeStyle = '#ddd';\\n```\\n\\n#### 字体设置\\n```\\n// 设置字体字号字重\\nctx.font = 'bold 12px sanserif';\\n\\n// 设置文本水平对齐方式\\nctx.textAlign = 'left' // 文本左对齐\\nctx.textAlign = 'center' // 文本水平居中\\nctx.textAlign = 'right' // 文本右对齐\\n\\n// 设置文本基线位置\\nctx.textBaseline = 'top' // 顶部对齐\\nctx.textBaseline = 'middle' // 垂直居中对齐\\nctx.textBaseline = 'bottom' // 底部部对齐\\nctx.textBaseline = 'hanging' // 悬挂基线对齐\\nctx.textBaseline = 'alphabetic' // 字母基线对齐\\n```\\n#### 线型设置\\n```\\n// 设置线宽\\nctx.lineWidth = 1;\\n\\n// 设置线型\\nctx.setLineDash([1,0]); // 实线效果\\nctx.setLineDash([1,1]); // 虚线效果\\n\\n// 端点形状\\nctx.lineCap = 'butt' // 方形\\nctx.lineCap = 'butt' // 方形，多出半个线宽的厚度\\nctx.lineCap = 'round' // 圆形\\n\\n// 拐点形状\\nctx.lineJoin = 'miter' // 尖角\\nctx.lineJoin = 'bevel' // 平角\\nctx.lineJoin = 'round' // 圆角\\n```\\n\\n## 绘制矩形\\n绘制矩形分填充矩形和描边矩形两种方式\\n### 填充矩形 - fillRect\\n```\\n/**\\n * fillRect 填充矩形\\n * @param {Number} x 横坐标\\n * @param {Number} y 纵坐标\\n * @param {Number} width 宽度\\n * @param {Number} height 高度\\n **/\\n\\n// 在坐标（100，100）的位置，绘制一个50*50的蓝色矩形；\\nctx.fillStyle = 'blue';\\nctx.fillRect(100, 100, 50, 50);\\n```\\n### 描边矩形 - strokeRect\\n```\\n/**\\n * strokeRect 描边矩形\\n * @param {Number} x 横坐标\\n * @param {Number} y 纵坐标\\n * @param {Number} width 宽度\\n * @param {Number} height 高度\\n **/\\n\\n// 在坐标（100，100）的位置，绘制一个边框宽度为2px，尺寸为50*50的黑色矩形框；\\nctx.lineWidth = 2;\\nctx.strokeStyle = 'black';\\nctx.strokeRect(100, 100, 50, 50);\\n```\\n\\n## 绘制字体\\n绘制字体同样分为填充字体和描边字体两种方式\\n### 填充字体 - fillText\\n```\\n/**\\n * fillText 填充字体\\n * @param {String} text 文本内容\\n * @param {Number} x 横坐标\\n * @param {Number} y 纵坐标\\n **/\\n\\n// 以（100，100）为中心点，绘制 'Hello World' 字符；\\nctx.textAlign = 'center';\\nctx.textBaseline = 'middle';\\nctx.fillText('Hello World');\\n```\\n### 描边字体 - strokeText\\n```\\n/**\\n * strokeText 描边字体\\n * @param {String} text 文本内容\\n * @param {Number} x 横坐标\\n * @param {Number} y 纵坐标\\n **/\\n\\nctx.strokeText('描边字体', 100, 100);\\n```\\n\\n## 绘制图片\\n```\\n/**\\n * drawImage \\n * @param {ImageSource} image 图片\\n * @param {Number} x 横坐标\\n * @param {Number} y 纵坐标\\n * @param {Number} width 宽度\\n * @param {Number} height 高度\\n **/\\n\\nctx.drawImage(img, 0, 0, 100, 100);\\n```\\n\",\"topic\":\"Canvas 绘图\",\"keywords\":[\"canvas\",\"js\"]}}")},"5f3a":function(n){n.exports=JSON.parse('{"value":{"id":"1646043364532","title":"Vue 数据响应式原理","content":"### defineProperty\\\\defineProperties\\n\\n### Proxy\\n\\n","topic":"Vue","keywords":["vue","js","javascript"]}}')},"763d":function(n){n.exports=JSON.parse('{"value":{"id":"1646043652524","title":"vue 渲染函数","content":"# h(node, nodeAttr, children)","topic":"Vue","keywords":["vue","js","javascript"]}}')},b467:function(n){n.exports=JSON.parse('{"value":{"id":"1646043487123","title":"vue 组合api","content":"## setup\\n\\n## ref/reactive\\n\\n## 声明周期\\n\\n## computed\\n\\n## watch/watchEffect\\n\\n## defineProps\\n\\n## defineEmits\\n\\n## defineExpose\\n\\n","topic":"Vue","keywords":["vue","js","javascript"]}}')},be35:function(n,e,t){},c74e:function(n){n.exports=JSON.parse('{"value":{"id":"1645433524733","title":"Typescript 基础","content":"## 数据类型\\n## 接口定义\\n## 类\\n## 高级类型\\n## 类型转换\\n","topic":"","keywords":["typescript"]}}')},cb12:function(n){n.exports=JSON.parse('{"value":{"id":"1645433467140","title":"Vue 数据传递","content":"1. props & emit\\n2. v-model\\n2. provide & inject\\n3. store","topic":"Vue","keywords":["vue"]}}')},cd49:function(n,e,t){"use strict";t.r(e);t("e260"),t("e6cf"),t("cca6"),t("a79d");var r=t("7a23");function o(n,e){var t=Object(r["resolveComponent"])("router-view");return Object(r["openBlock"])(),Object(r["createBlock"])(t)}var a=t("6b0d"),c=t.n(a);const i={},d=c()(i,[["render",o]]);var s=d,u=(t("d3b7"),t("3ca3"),t("ddb0"),t("6c02")),l=[{path:"/",component:function(){return t.e("home").then(t.bind(null,"38c6"))},redirect:"/home",children:[{path:"/home",component:function(){return t.e("home").then(t.bind(null,"bb51"))}},{path:"/about",component:function(){return t.e("about").then(t.bind(null,"613f"))}},{path:"/doc",component:function(){return Promise.all([t.e("doc~doc-editor~doc-reader"),t.e("doc")]).then(t.bind(null,"0b0e"))}},{path:"/doc/:id",component:function(){return Promise.all([t.e("doc~doc-editor~doc-reader"),t.e("doc-reader")]).then(t.bind(null,"fb90"))}},{path:"/doc/:id/edit",component:function(){return Promise.all([t.e("doc~doc-editor~doc-reader"),t.e("doc-editor")]).then(t.bind(null,"6baa"))}}]},{path:"/demo/canvas/firework",component:function(){return t.e("firework").then(t.bind(null,"f628"))}}],m=Object(u["a"])({history:Object(u["b"])(),routes:l}),p=m,b=t("5502"),h=Object(b["a"])({state:{},mutations:{},actions:{},modules:{}}),g=(t("27dc"),t("d9b6"),t("be35"),t("c3a1")),f=(t("159b"),t("caad"),t("2532"),t("490c")),x=[t("5e74"),t("405a"),t("cb12"),t("c74e"),t("5dcd"),t("5b24"),t("5f3a"),t("b467"),t("763d"),t("e26c"),t("56af")],v=["Canvas 绘图","Vue","Adobe CEP 插件开发"],y=f["a"].get("docs")||[],k=f["a"].get("topics")||[];x.forEach((function(n){f["a"].set(n.value.id,n.value),y.includes(n.value.id)||y.push(n.value.id)})),v.forEach((function(n){-1===k.indexOf(n)&&k.push(n)})),f["a"].set("docs",y),f["a"].set("topics",k),Object(r["createApp"])(s).use(h).use(p).use(g["a"]).mount("#app")},e26c:function(n){n.exports=JSON.parse('{"value":{"id":"1646043731876","title":"vue虚拟DOM","content":"","topic":"Vue","keywords":[]}}')}});
//# sourceMappingURL=app.a3b07e17.js.map